# Комментарии и объяснения к заданиям

## Задание № 1

ПЛЮСЫ:

*Пример*
+ Интуитивно понятнее
+ Легче читать и поддерживать

*Реализация*
+ Валидация передаваемого числа
+ Более дружелюбный UI

МИНУСЫ:

*Реализация*
- Скорость выполнения ниже чем у функции в примере: `О(n) < O(1)`
- Величина передаваемого для анализа числа ограничена показателем глубины рекурсии.
  (Для данного примера должно быть примерно `user_num < 2 * sys.getrecursionlimit()`)
- Размер кода увеличился, читаемость уменьшилась (в сравнении с примером)

***

## Задание № 2

В первой реализации (с помощью класса *FirstCustomFIFO*) недостатком является пустая,
но по факту искусственно созданная и заполненная значениями `None` очередь. Таким образом если очередь
заполнена не полностью, а пользователь запросит все объекты очереди,
то ему вернуться и вставленные по умолчанию None, хотя он их сам туда не добавлял. С другой стороны,
благодаря заранее заполненной очереди, обе операции (по добавлению и удалению объектов)
теперь выполняются за `О(1)` вместо `O(n)` (что характерно для подобных
методов списка в худшем случае), т.к. мы меняем лишь значение элементу очереди, а не двигаем их в памяти компьютера.

Во второй реализации (с помощью класса *SecondCustomFIFO*), плюсом считаю что его встроенные методы `append` и `popleft`
сразу имеют скорость выполнения `О(1)`, и при этом запрашиваемая очередь всегда будет содержать только добавленные
пользователем элементы и ничего лишнего. А так как это реализация FIFO и вставок в середину очереди не будет, то и
скорость выполнения операций добавления/удаления останется постоянной.

***

## Задание № 3

Если я правильно понял задание, то нужно написать быстрейший из алгоритмов реализацию которого я могу написать сам.
Вообще протестировал несколько алгоритмов, самый быстрый у меня получился это встроенный `sorted()` (алгоритм Timsort), 
однако самостоятельно его реализацию я пока не напишу. Поэтому мой личный выбор пал на быструю сортировку. По замерам она 
показала лучший результат. Сама по себе имеет в среднем и лучшем случае время выполнения `O(n*logn)` что быстрее
многих сортировок за `O(n ** 2)`, и даже быстрее некоторых остальных в своей временной категории за счёт константы. 
А шанс худшего случая выполнения алгоритма мы минимизируем явно указав что опорный элемент (переменная `pivot`) должен
выбираться где-то посередине массива, а не первым/последним элементом.

***
